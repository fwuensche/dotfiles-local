# New Block
snippet beg
	begin
		${3}
	rescue ${1:Exception} => ${2:e}
	end

snippet req
	require "${1}"${2}
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end

snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet for
	for ${1:e} in ${2:c}
		${3}
	end		
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end	
snippet eai
	each_index { |${1:i}| ${2} }
snippet eaid
	each_index do |${1:i}|
	end
snippet eak
	each_key { |${1:key}| ${2} }
snippet eakd
	each_key do |${1:key}|
		${2}
	end
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${3}
	end			
snippet eav
	each_value { |${1:val}| ${2} }
snippet eavd
	each_value do |${1:val}| 
		${2}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet eawid
	each_with_index do |${1:e},${2:i}|
		${3}
	end
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet reved
	reverse_each do |${1:e}|
		${2}
	end	
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end		
snippet map
	map { |${1:e}| ${2} }
snippet mapd
	map do |${1:e}| 
		${2}
	end		
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet det
	detect { |${1:e}| ${2} }
snippet detd
	detect do |${1:e}|
		${2}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet find
	find do |${1:e}|
		${2}
	end		
snippet fina
	find_all { |${1:e}| ${2} }
snippet finad
	find_all do |${1:e}|
		${2}
	end			
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${3}
	end		
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet pard
	partition do |${1:e}|
		${2}
	end		
snippet rej
	reject { |${1:e}| ${2} }
snippet rejd
	reject do |${1:e}|
		${2}
	end
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end		
snippet lam
	-> { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet tas
	desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end

# RSpec-related personal snippets
snippet desc
	describe "${1:thing to be described}" do
		${2:pending}
	end

snippet cont
	context "${1:context_description}" do
		${2:pending}
	end

snippet itd
	it "${1:behavior}" do
		${2:pending}
	end

snippet allow
	allow(${1:object}).to receive(:${2:method})

snippet allowr
	allow(${1:object}).to receive(:${2:method}) { ${3:return_value} }

snippet exp
	expect(${1:object}).to ${2:matcher}

snippet expw
	expect(${1:object}).to have_received(:${2:method}).with(${3:arguments})

snippet itshdb
  it { should have_db_index(:${1:reference}_id) }

snippet itsb
  it { should belong_to(:${1:owner}) }

snippet itshm
  it { should have_many(:${1:owner}s) }

snippet itsho
  it { should have_one(:${1:owner}) }

snippet itshmt
  it { should have_many(:${1:owner}s).through(:${2:via}) }

snippet itsvp
  it { should validate_presence_of(:${1:attribute}) }
